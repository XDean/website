[
	{
		"path": "public/blog/posts/2021/typescript/types.md",
		"link": "/blog/posts/2021/typescript/types",
		"title": "Typescript 类型详解",
		"summary": [
			"自2012年诞生至今已有10个年头，Typescript已然成为Javascript项目的标配。\nTypescript的类型系统是笔者学过的几门语言中表现力最强的，同时也兼顾了可读性易用性。",
			"本文将介绍Typescript的类型系统的各种(高级)用法，帮助你在需要时定义更贴合业务的强大类型。",
			"关于基础知识，在这里不做赘述，如有需要请自行阅读官方文档。主要包括",
			"Typescript的类型可以通过逻辑与或进行组合，这种方式被称为联合类型",
			"Playground Link: Provided"
		],
		"image": "",
		"author": "",
		"contributors": [],
		"created": "2021-06-19T00:00:00.000Z",
		"updated": "",
		"tags": [
			"Typescript"
		],
		"categories": [
			"Coding"
		],
		"date": "2021-06-19T00:00:00.000Z"
	},
	{
		"path": "public/blog/posts/2021/pwa/pwa.md",
		"link": "/blog/posts/2021/pwa/pwa",
		"title": "Progressive Web Apps 渐进式网页应用入门",
		"summary": [
			"渐进式网页应用(简称PWA)是一种Web应用标准。\n通过使用一系列新兴技术让你的Web应用快速，安全，可安装，可离线使用，可适配各种设备，使其拥有不亚于原生应用的使用体验。\n主要技术包括App Manifest, Service Worker, Web Push等",
			"PWA最早由Google于2015年发起，同年Chrome支持Service Worker。\n之后，Safari和Edge也相继在2018年和2019年提供支持。",
			"随着十多年来智能手机的发展和普及，人们访问互联网的方式已经改变，移动互联网的使用率已超过传统互联网。\n数据显示，终端用户有87%的时间花费在手机应用上，相对的，网页只占到不足"
		],
		"image": "pwa.svg",
		"author": "dxu",
		"contributors": [
			"dxu"
		],
		"created": "2021-05-10T00:00:00.000Z",
		"updated": "Wed May 19 2021 08:49:02 GMT+0800 (China Standard Time)",
		"tags": [
			"PWA",
			"Web"
		],
		"categories": [
			"Coding"
		],
		"date": "2021-05-10T00:00:00.000Z"
	},
	{
		"path": "public/blog/posts/topics/spark/barrier.md",
		"link": "/blog/posts/topics/spark/barrier",
		"title": "Spark Barrier Execution Mode 屏障执行模式",
		"summary": [
			"屏障执行模式(Barrier Execution Mode)是Spark 2.4版本引入的新的执行模式。\n旨在支持让Spark平台支持更多样化的工作类型，例如调度ML(机器学习)/DL(深度学习)训练任务。\n本文将带你了解什么是屏障执行模式，为什么Spark需要，以及如何使用。",
			"MapReduce是大多数流行框架的执行模式，通过划分Map和Reduce阶段(Stage)，可以灵活的处理各种作业(Job)。",
			"在MapReduce中",
			"虽然MapReduce已经实践了很多年，但是在近几年流行的深度学习领域却无能为力。\n神经网络中的任务很难通过MapReduce模型进行抽象，一般通过MPI或其他模型。\n为了"
		],
		"image": "spark_big_data.jpg",
		"author": "dxu",
		"contributors": [
			"dxu"
		],
		"created": "2021-05-08T00:00:00.000Z",
		"updated": "Sat May 08 2021 15:58:44 GMT+0800 (China Standard Time)",
		"tags": [
			"Spark"
		],
		"categories": [
			"Coding"
		],
		"date": "2021-05-08T00:00:00.000Z"
	},
	{
		"path": "public/blog/posts/2021/distributed-computing/index.md",
		"link": "/blog/posts/2021/distributed-computing/index",
		"title": "大数据和分布式计算发展简史",
		"summary": [
			"在当今这个时代，大数据已经不是什么新鲜的名词了。\n但凡是小有规模的公司，都配备了专门的数据部门。\n而且这里的公司可不只是互联网公司，而是涵盖了能源，医疗，通信，零售，娱乐等等。\n以至于数据本身成为了一种宝贵的资产，谁拥有了数据就拥有了未来。",
			"但是，光有数据还不够，数据本身不会说话。我们需要对数据进行处理和挖掘。\n这中间就需要用到我们的主角——分布式计算。",
			"如果你是软件相关从业人员并且关心行业新闻，一定对Hadoop，Hive，Yarn，Spark这些技术如雷贯耳。\n任何技术都不是一蹴而就的，它们的诞生是随着历史的演进，偶然亦或必然地被选择。",
			"注：分布式计算和大数据并非同义词，本文仅讨论重合部分的一个"
		],
		"image": "images/big-data.webp",
		"author": "dxu",
		"contributors": [
			"dxu"
		],
		"created": "2021-03-15T00:00:00.000Z",
		"updated": "Mon Mar 22 2021 14:54:30 GMT+0800 (China Standard Time)",
		"tags": [
			"Distribution",
			"Big Data"
		],
		"categories": [
			"Coding"
		],
		"date": "2021-03-15T00:00:00.000Z"
	},
	{
		"path": "public/blog/posts/2021/deno.md",
		"link": "/blog/posts/2021/deno",
		"title": "认识Deno — 2020年最受瞩目的JS项目",
		"summary": [
			"2020年刚刚过去不久，对于现实世界来说是特殊的一年，对于Javascript世界也是特殊的一年。\n在Github Javascript排行榜上，Deno一举击败了蝉联5年冠军的Vue.js ，以30.2kstar荣登榜首。\n如果你不太关注前沿消息，你一定会问，这个雨点里的小恐龙是什么来头？",
			"简单的说，Deno(蒂诺)是一个Javascript运行时。",
			"这是你要问了，JS运行时，我们不是有Node了么？\n是的，Deno就是Node的——翻转, no-de => de-no。",
			"不止如此，Deno和Node还有同一个父亲，Ryan Dahl (ry@github)。\n虽然ry已经9年没有维护Node了，"
		],
		"image": "deno-logo.png",
		"author": "dxu",
		"contributors": [
			"dxu",
			"Dean Xu"
		],
		"created": "2021-03-09T00:00:00.000Z",
		"updated": "Thu Mar 25 2021 08:38:10 GMT+0800 (China Standard Time)",
		"tags": [
			"Deno",
			"Typescript"
		],
		"categories": [
			"Coding"
		],
		"date": "2021-03-09T00:00:00.000Z"
	},
	{
		"path": "public/blog/posts/2020/spark-efficient-range-joins/index.md",
		"link": "/blog/posts/2020/spark-efficient-range-joins/index",
		"title": "[译] Spark高效范围连接 (Spark Efficient Range-Joins)",
		"summary": [
			"原文地址：http://zachmoshe.com/2016/09/26/efficient-range-joins-with-spark.html",
			"如果你有用Spark进行过时间序列分析，你可能会碰到这种情况：根据时间戳范围进行JOIN。",
			"本文我们假设有两个DataFrame，",
			"我们想要把每个事件和一小时内的测量值合并。",
			"一种显而易见的方法是使用范围条件查询,形如measurementTime BETWEEN eventTime - n AND eventTime\n，这将导致JOIN操作进行一次完整的笛卡尔乘积然后执行过滤。\n这种做法的效率很低，尤其是当数据量达到数十万的情况下。"
		],
		"image": "images/window-grouping.png",
		"author": "dxu",
		"contributors": [
			"dxu"
		],
		"created": "2020-10-26T00:00:00.000Z",
		"updated": "",
		"tags": [
			"Spark",
			"Translation",
			"Big Data"
		],
		"categories": [
			"Coding"
		],
		"date": "2020-10-26T00:00:00.000Z"
	},
	{
		"path": "public/blog/posts/2020/restful.md",
		"link": "/blog/posts/2020/restful",
		"title": "理解 REST API",
		"summary": [
			"REST这个单词想必作为开发者都不陌生。\n在“大前端时代”的今天，一旦提及前后端交互，REST总是被提起。\n但是我们却模糊了REST的概念，它更多的时候指代了以JSON为载体的WEB交互。\n这其实与REST的初衷并不相符。我们有必要重新认识REST。",
			"REST全称 REpresentational State Transfer。\n由Roy Thomas Fielding博士在2000年于其论文 Architectural Styles and the Design of Network-based Software Architectures 中提出的。\n是一种分布式超媒体架构风格。",
			"一个接口要称"
		],
		"image": "",
		"author": "dxu",
		"contributors": [
			"dxu"
		],
		"created": "2020-08-05T00:00:00.000Z",
		"updated": "",
		"tags": [
			"REST"
		],
		"categories": [
			"Coding"
		],
		"date": "2020-08-05T00:00:00.000Z"
	},
	{
		"path": "public/blog/posts/topics/spring-boot/jpa/envers/1.md",
		"link": "/blog/posts/topics/spring-boot/jpa/envers/1",
		"title": "Spring Boot JPA - Hibernate Envers",
		"summary": [
			"虽然Spring Data JPA有默认的Auditing功能，但是功能还是相对单薄。",
			"而Hibernate Envers是Hibernate提供的完整Auditing方案，可以记录Entity的历史版本和版本信息。\n可以帮助找回丢失数据，检查修改历史以及数据分析。",
			"Hibernate Envers和Spring Data JPA无缝集成，只需要简单地加上注解就可以工作。",
			"首先需要添加依赖项",
			"接着，在你的Entity类上打上@Audited，就大功告成了。\n现在一个最简单的审计功能已经可以正常工作"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2020-08-04T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Java",
			"Spring Boot",
			"Hibernate"
		],
		"categories": [
			"Coding"
		],
		"date": "2020-08-04T00:00:00.000Z",
		"src": [
			{
				"text": "Source Code",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/jpa/audit"
			}
		]
	},
	{
		"path": "public/blog/posts/topics/react/1.md",
		"link": "/blog/posts/topics/react/1",
		"title": "React 入门教程 (1)",
		"summary": [
			"React is a JavaScript library for building user interfaces.",
			"React isn’t an MVC framework.",
			"React doesn’t use templates.",
			"React 是一个用于构建用户界面的 JavaScript 库",
			"React不是MVC框架"
		],
		"image": "",
		"author": "dxu",
		"contributors": [
			"dxu"
		],
		"created": "2020-07-19T00:00:00.000Z",
		"updated": "",
		"tags": [
			"Frontend",
			"React"
		],
		"categories": [
			"Coding"
		],
		"date": "2020-07-19T00:00:00.000Z"
	},
	{
		"path": "public/blog/posts/topics/spring-boot/extra/5-async.md",
		"link": "/blog/posts/topics/spring-boot/extra/5-async",
		"title": "Spring Boot 番外 (05) - 异步 Async",
		"summary": [
			"在Java中，异步操作通常需要自己开启线程或者管理线程池。",
			"到了Spring Boot中，通过容器的特性在上下文中提供线程池，可以做到轻松方便的异步操作。\nSpring Boot提供了@Async异步注解，让我们可以彻底告别过去，不需要处处和线程/线程池打交道。",
			"要开启异步功能，只需要添加上@EnableAsync注解即可。",
			"开启后，在你想要异步操作的方法加上@Async注解就大功告成了。",
			"@Async方法返回值必须为以下几种类型之一"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2020-04-28T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Java",
			"Spring Boot"
		],
		"categories": [
			"Coding"
		],
		"date": "2020-04-28T00:00:00.000Z",
		"prev": "4-caching.md",
		"src": [
			{
				"text": "Async",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/async"
			}
		]
	},
	{
		"path": "public/blog/posts/topics/spring-boot/extra/4-caching.md",
		"link": "/blog/posts/topics/spring-boot/extra/4-caching",
		"title": "Spring Boot 番外 (04) - 缓存 Cache",
		"summary": [
			"对于程序员，缓存一定不是一个陌生的概念。\n在我们编写的程序中，数据的处理和传递无时无刻不在发生着。\n而其中总会存在着一些的重复的操作和数据。",
			"为了减少这种浪费，也为了加快响应时间，我们就需要缓存。\n把处理好的数据保留下来(最常见的是放在内存)，下次再要做相同的事情，就可以直接返回结果。",
			"Spring Boot核心库就为我们提供了缓存功能，相关代码在org.springframework.cache包下。",
			"要开启缓存功能，只需要添加上@EnableCaching注解即可。\n接着我们就要在需要的方法上加上注解来实现缓存。\nSpring Boot提供了以下几种注解。",
			"其中，前三个注解是核心，每个注解都有若干"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2020-02-10T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Java",
			"Spring Boot"
		],
		"categories": [
			"Coding"
		],
		"date": "2020-02-10T00:00:00.000Z",
		"prev": "3-encrypt.md",
		"next": "5-async.md",
		"src": [
			{
				"text": "Caching",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/cache"
			}
		]
	},
	{
		"path": "public/blog/posts/topics/spring-boot/extra/3-encrypt.md",
		"link": "/blog/posts/topics/spring-boot/extra/3-encrypt",
		"title": "Spring Boot 番外 (03) - 敏感信息加密 Encrypt",
		"summary": [
			"在所有的应用中，我们会需要一些配置信息，其中难免会有一些敏感信息。\n如果明文将他们放到仓库里，这些信息就会泄露。而如果我们不放在仓库里，又会给我们的部署带来麻烦。\n因此，加密敏感信息就成了必要的需求了。",
			"基于Spring Boot的容器特性，我们其实很容易切入配置文件的加载，来处理加密信息。",
			"我们想要的是，把编码后的数据放到配置中，而在容器里拿到的却是解码后的内容。",
			"所以首先我们得有一条绝密的字符串Hello World，然后我们用复杂的BASE64算法进行编码，得到了SGVsbG8gV29ybGQ=。\n把它放到application.yaml里。为了区别于未加密的信息，我们以base64:开头：",
			"现"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2020-02-04T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Java",
			"Spring Boot"
		],
		"categories": [
			"Coding"
		],
		"date": "2020-02-04T00:00:00.000Z",
		"prev": "2-custom-condition.md",
		"next": "4-caching.md",
		"src": [
			{
				"text": "Custom Encrypt",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/encrypt/src/main/java/xdean/share/spring/encrypt/custom"
			},
			{
				"text": "Jasypt Encrypt",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/encrypt/src/main/java/xdean/share/spring/encrypt/jasypt"
			}
		]
	},
	{
		"path": "public/blog/posts/topics/spring-boot/6.md",
		"link": "/blog/posts/topics/spring-boot/6",
		"title": "Spring Boot (06) - Auto Configuration 自动配置 与 Starter 启动器",
		"summary": [
			"前面几节讲解了Spring容器以及Bean的用法。\n其实至此Spring的核心功能已经结束了，从本节往后所有的功能不过是在容器之内所做的拓展。\n对于Spring Boot自己来说，最重要的功能就是Auto Configuration(自动配置)了。",
			"对于经历过传统Spring的开发者来说，Spring Boot无疑是大大解放了生产力。\n其\"约定优于配置\"的思想将我们从无数的配置文件中解放出来。\n大部分时候我们不需要任何配置就可以获得想要的对象。",
			"例如在我们第一节的Hello-Web中，没有做任何Web相关配置却成功的启动了一个Web服务。\n又比如如果你想要一个内存数据库，只需要引入HSQLDB作为"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2019-11-04T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Java",
			"Spring Boot"
		],
		"categories": [
			"Coding"
		],
		"date": "2019-11-04T00:00:00.000Z",
		"prev": "5.md"
	},
	{
		"path": "public/blog/posts/2019/ui-task-optimize/index.md",
		"link": "/blog/posts/2019/ui-task-optimize/index",
		"title": "UI事件线程任务调度优化",
		"summary": [
			"一般UI框架都是单线程事件模型。一个典型的UI线程如图",
			"在UI初始化后，除了不断地处理用户事件以外。还会维护一个事件队列以接收其他线程调度来的任务。UI框架会提供接口以调度任务回UI线程。例如",
			"一般对于耗时操作，我们会先在任务线程里运行，得到结果后调度回到UI线程进行更新。",
			"但是对于一些特定业务，即使调度得到也仍会造成UI卡顿。例如：",
			"针对以上两种情况，我们对UI事件线程进行优化。通过自定义的调度器来取代原生调度器，从而使UI更加顺滑。\n我们先来看看解决问题的效果，然后解析实现原理。"
		],
		"image": "ui-loop.svg",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2019-10-15T00:00:00.000Z",
		"updated": "Mon Mar 08 2021 14:27:54 GMT+0800 (China Standard Time)",
		"tags": [
			"Java",
			"GUI"
		],
		"categories": [
			"Coding"
		],
		"date": "2019-10-15T00:00:00.000Z",
		"src": [
			{
				"text": "FxRunCenter",
				"url": "https://github.com/XDean/Share/blob/master/src/main/java/xdean/share/gui/schedule/FxRunCenter.java"
			}
		]
	},
	{
		"path": "public/blog/posts/topics/spring-boot/extra/2-custom-condition.md",
		"link": "/blog/posts/topics/spring-boot/extra/2-custom-condition",
		"title": "Spring Boot 番外 (02) - 自定义Condition",
		"summary": [
			"Spring Boot提供了Condition接口来自定义Conditional。它只有一个方法",
			"同时，对于每个Condition要定义对应的注解以标记Bean需要满足该条件。",
			"这里我们依然以'世界'为例，在不同的世界里我们需要不同的Bean。",
			"首先我们实现WorldCondition",
			"接着我们再定义对应的注解@OnWorld，指定WorldCondition为它的处理类"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2019-09-10T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Java",
			"Spring Boot"
		],
		"categories": [
			"Coding"
		],
		"date": "2019-09-10T00:00:00.000Z",
		"prev": "1-custom-scope.md",
		"next": "3-encrypt.md",
		"src": [
			{
				"text": "WorldScope",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/customcondition"
			}
		]
	},
	{
		"path": "public/blog/posts/topics/spring-boot/extra/1-custom-scope.md",
		"link": "/blog/posts/topics/spring-boot/extra/1-custom-scope",
		"title": "Spring Boot 番外 (01) - 自定义Scope",
		"summary": [
			"ConfigurableBeanFactory提供了接口來进行自定义Scope的注册",
			"我们只需要实现Scope接口，注意这里的Scope不是注解@Scope。",
			"Scope接口有如下定义(下文中所有上下文均指代作用域的上下文)",
			"Spring附赠了一个简单实现的SimpleThreadScope可以作为参考。",
			"在这里我们一起来创建一个新的WorldScope(平行世界)，通过一个全局的世界标识符来决定当前上下文。"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2019-09-09T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Java",
			"Spring Boot"
		],
		"categories": [
			"Coding"
		],
		"date": "2019-09-09T00:00:00.000Z",
		"next": "2-custom-condition.md",
		"src": [
			{
				"text": "WorldScope",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/customscope"
			}
		]
	},
	{
		"path": "public/blog/posts/topics/spring-boot/5.md",
		"link": "/blog/posts/topics/spring-boot/5",
		"title": "Spring Boot (05) - Bean的配置与生命周期",
		"summary": [
			"Spring Boot提供了一系列的注解来帮助我们配置Bean，从而正确地找到合适地依赖项。",
			"在Spring中，Bean默认是单例的，如果想要非单例的Bean，你需要定义@Scope，即作用域。",
			"在Spring核心库中，只有两种scope，singleton和prototype。\n同时你也可以根据业务需求自定义scope，如Spring-Web中有request,session等",
			"例如",
			"输出"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2019-09-05T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Java",
			"Spring Boot"
		],
		"categories": [
			"Coding"
		],
		"date": "2019-09-05T00:00:00.000Z",
		"prev": "4.md",
		"next": "6.md",
		"src": [
			{
				"text": "@Scope",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/scope"
			},
			{
				"text": "@Conditional",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/conditional"
			},
			{
				"text": "@DependsOn",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/dependson"
			},
			{
				"text": "生命周期",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/lifecycle"
			}
		]
	},
	{
		"path": "public/blog/posts/topics/spring-boot/4.md",
		"link": "/blog/posts/topics/spring-boot/4",
		"title": "Spring Boot (04) - Bean的发现",
		"summary": [
			"上文讲到如何将Bean注册到容器中。整个过程看上去像是魔法一样，没有任何耦合，只是加了一个注解就完成了。",
			"其实秘密就藏在了注解里，注解包含了配置项，Spring容器解析注解从而找到你的Bean。",
			"在Spring中主要有两种方式发现你的Bean",
			"@ComponentScan告诉Spring容器通过类路径扫描来发现用户定义的Bean。\n你可能会想你并没有定义过这一注解，让我们点开@SpringBootApplication类源码，你会发现它已经包含了@ComoponentScan。",
			"@ComponentScan`主要属性有"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2019-09-03T00:00:00.000Z",
		"updated": "Wed Apr 07 2021 21:39:44 GMT+0800 (China Standard Time)",
		"tags": [
			"Java",
			"Spring Boot"
		],
		"categories": [
			"Coding"
		],
		"date": "2019-09-03T00:00:00.000Z",
		"prev": "3.md",
		"next": "5.md",
		"src": [
			{
				"text": "@ComponentScan",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/componentscan"
			},
			{
				"text": "@Import",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/importoutside"
			},
			{
				"text": "Spring Boot 源码",
				"url": "https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java"
			}
		]
	},
	{
		"path": "public/blog/posts/2019/go-enc-config.md",
		"link": "/blog/posts/2019/go-enc-config",
		"title": "Go - 配置文件加密",
		"summary": [
			"任何应用都不可避免地要使用配置文件，而一些配置信息包含敏感信息，如果明文放在配置文件中上传到远程仓库里显然是不合适地。",
			"一种做法是在仓库里不记录敏感信息，而在生产环境下单独配置。这样虽然保护了信息但是会变得非常麻烦，换一个环境又要重新配置。",
			"而我的做法是直接在配置文件中加密，通过一个统一密钥来管理所有的敏感信息。",
			"我们有如下配置项",
			"对应的我们有"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2019-09-02T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Golang"
		],
		"categories": [
			"Coding"
		],
		"date": "2019-09-02T00:00:00.000Z",
		"src": [
			{
				"text": "源码",
				"url": "https://github.com/XDean/goex/blob/master/xconfig/encrypt.go"
			},
			{
				"text": "示例",
				"url": "https://github.com/XDean/Share/tree/master/src/go/config/enc"
			}
		]
	},
	{
		"path": "public/blog/posts/topics/spring-boot/3.md",
		"link": "/blog/posts/topics/spring-boot/3",
		"title": "Spring Boot (03) - 容器与Bean",
		"summary": [
			"在开篇\"Spring Boot是什么\"一节，我们讲到Spring Boot是一个容器。\n如果你有心翻看Spring Boot Starter的依赖，你会发现除了包含基础设施的spring-core项目外，最主要的项目便是spring-context，直译为上下文，亦即容器。",
			"即使你没有用过Spring也一定听过依赖注入/控制反转。\n在大型项目中，代码中存在千丝万缕的依赖关系，如果不能正确管理这些依赖关系，生产效率和质量都会大打折扣。例如下面这个例子",
			"A依赖于B，这看上去没什么问题，但是想象一下让你来写这段代码，问题迎面而来",
			"紧接着再来想象一下让你来维护这段代码",
			"无数问题将困扰开发人员，使得我们花了太多"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2019-08-30T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Java",
			"Spring Boot"
		],
		"categories": [
			"Coding"
		],
		"date": "2019-08-30T00:00:00.000Z",
		"prev": "2.md",
		"next": "4.md",
		"src": [
			{
				"text": "@Component",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/component"
			},
			{
				"text": "@Bean",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/bean"
			},
			{
				"text": "@Autowired",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/autowired"
			}
		]
	},
	{
		"path": "public/blog/posts/topics/spring-boot/2.md",
		"link": "/blog/posts/topics/spring-boot/2",
		"title": "Spring Boot (02) - 元注解",
		"summary": [
			"在Spring Boot中大量使用注解来简化配置。\n但是随着注解的增加，重复的注解本身又变得繁琐。",
			"所以Spring Boot定义了新的元注解(Meta-Annotation)结构来简化重复注解的配置。",
			"注意：Spring Boot元注解的定义方式只作用于由Spring Boot框架解析的注解。其他第三方项目的注解不一定使用了这一框架来解析。",
			"现在我们有一组常用的配置，我们需要在很多地方重复定义",
			"而在Spring Boot中你可以这样定义"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2019-08-28T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Java",
			"Spring Boot"
		],
		"categories": [
			"Coding"
		],
		"date": "2019-08-28T00:00:00.000Z",
		"src": [
			{
				"text": "AnnotationUtils",
				"url": "https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java"
			},
			{
				"text": "SynthesizedAnnotationInvocationHandler",
				"url": "https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-core/src/main/java/org/springframework/core/annotation/SynthesizedAnnotationInvocationHandler.java"
			},
			{
				"text": "AbstractAliasAwareAnnotationAttributeExtractor",
				"url": "https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-core/src/main/java/org/springframework/core/annotation/AbstractAliasAwareAnnotationAttributeExtractor.java"
			}
		],
		"prev": "1.md",
		"next": "3.md"
	},
	{
		"path": "public/blog/posts/topics/spring-boot/1.md",
		"link": "/blog/posts/topics/spring-boot/1",
		"title": "Spring Boot (01) - Hello World",
		"summary": [
			"尽管网上已经有许许多多的Spring Boot教程，但是其侧重点总是在如何搭建和配置WEB服务而非Spring Boot本身。\n本教程将着重于Spring Boot本身，一方面介绍核心特性的用法，一方面结合源码一步步揭开Spring Boot的\"魔法\"。",
			"Spring Boot提供的是一个快速开发框架，在其之上集成了许多组件集合可以开发各类应用，其中最常见的就是Web服务。本教程将主要针对Spring Boot本身和Spring Boot Web进行讲解。",
			"首先我们创建一个标准的maven工程，然后添加以下内容",
			"在dependencyManagement引入spring-boot-starter-p"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2019-08-26T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Java",
			"Spring Boot"
		],
		"categories": [
			"Coding"
		],
		"date": "2019-08-26T00:00:00.000Z",
		"src": [
			{
				"text": "Hello World",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/hello-world"
			},
			{
				"text": "Hello Web",
				"url": "https://github.com/XDean/Share/tree/master/src/spring-boot/hello-web"
			}
		],
		"next": "2.md"
	},
	{
		"path": "public/blog/posts/2019/ann/ann.md",
		"link": "/blog/posts/2019/ann/ann",
		"title": "了解经典人工神经网络 + Go语言实现",
		"summary": [
			"Go 语言实现经典神经网络 + 手写数字识别",
			"世界由数据（值）和过程（函数），而过程又有白盒和黑盒。对于黑盒的过程，我们虽然能够得到输入输出却不能确切了解到系统内部。例如",
			"这个简单的问题所有人脑都是一个实现，但是没有人可以用数字符号精确描述人脑是如何做到的。如何解析人脑构造似乎是脑科学家的工作，而统计学家（数据科学家）想要的只是以最低成本解答这一问题。这便开启了统计学回归分析的大门。(分类也可以看作是离散回归的一种，后文不作区分)",
			"自19世纪初高斯发明改进最小二乘法以来，200年间有许许多多的回归方法被发明。但是很可惜的是，这些方法都难以解决P问题。因为各种方法是针对给定条件建立的特异性模型，这也是"
		],
		"image": "unknown-system-fitting.png",
		"author": "dxu",
		"contributors": [
			"dxu"
		],
		"created": "2019-07-02T00:00:00.000Z",
		"updated": "",
		"tags": [
			"Machine Learning",
			"Golang"
		],
		"categories": [
			"Coding"
		],
		"date": "2019-07-02T00:00:00.000Z"
	},
	{
		"path": "public/blog/posts/2019/database-normalize.md",
		"link": "/blog/posts/2019/database-normalize",
		"title": "Database Normalize 数据库正则化",
		"summary": [
			"Database normalization is the process of structuring a relational database in accordance with a series of so-called normal forms in order to reduce data redundancy and improve data integrity. It was first proposed by Edgar F. Codd as an integral part of his relational model.\nNormalization entails or"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2019-06-27T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Database"
		],
		"categories": [
			"Coding"
		],
		"date": "2019-06-27T00:00:00.000Z"
	},
	{
		"path": "public/blog/posts/2018/java-memory-model.md",
		"link": "/blog/posts/2018/java-memory-model",
		"title": "理解Java内存模型",
		"summary": [
			"几天前我在stackoverflow上遇到了一个有趣的问题，我们从这个问题开谈起",
			"@Nik Kotovski:",
			"听说volatile可以阻止重排序，那么他的作用范围是多大呢？一行，一个大括号还是多少？举例：",
			"可以肯定的是k和v肯定不会重排序，那么i,j,flag和v呢？i,j,k之间呢？",
			"我的回答很长，浓缩成一句即是"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2018-10-12T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Java",
			"Memory Model"
		],
		"categories": [
			"Coding"
		],
		"date": "2018-10-12T00:00:00.000Z"
	},
	{
		"path": "public/blog/posts/2018/lambda/3-samples-and-hints.md",
		"link": "/blog/posts/2018/lambda/3-samples-and-hints",
		"title": "Lambda表达式(3) - 建议用法与示例",
		"summary": [],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2018-07-12T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Lambda",
			"Java"
		],
		"categories": [
			"Coding"
		],
		"date": "2018-07-12T00:00:00.000Z",
		"prev": "2-lambda-vs-method-reference.md"
	},
	{
		"path": "public/blog/posts/2018/lambda/2-lambda-vs-method-reference.md",
		"link": "/blog/posts/2018/lambda/2-lambda-vs-method-reference",
		"title": "Lambda表达式(2) - VS 方法引用",
		"summary": [],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2018-07-11T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Lambda",
			"Java"
		],
		"categories": [
			"Coding"
		],
		"date": "2018-07-11T00:00:00.000Z",
		"prev": "1-lambda-vs-anonymous.md",
		"next": "3-samples-and-hints.md"
	},
	{
		"path": "public/blog/posts/2018/lambda/1-lambda-vs-anonymous.md",
		"link": "/blog/posts/2018/lambda/1-lambda-vs-anonymous",
		"title": "Lambda表达式(1) - VS 匿名内部类",
		"summary": [],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2018-07-10T00:00:00.000Z",
		"updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
		"tags": [
			"Lambda",
			"Java"
		],
		"categories": [
			"Coding"
		],
		"date": "2018-07-10T00:00:00.000Z",
		"next": "2-lambda-vs-method-reference.md"
	},
	{
		"path": "public/blog/posts/topics/rxjava/4.md",
		"link": "/blog/posts/topics/rxjava/4",
		"title": "理解RxJava与响应式(4) - 背压",
		"summary": [
			"我们还是以吮指原味鸡为例，KFC分为后厨和前台。后厨产鸡(producer)，前台卖鸡(consumer)，由不同的人(thread)来负责。",
			"两种策略各有优劣，",
			"在实践中应该选用合适的模型。",
			"为了防止顾客久等，KFC在前台和后厨之间放置了一个货架(buffer)，用来暂时存放多于的鸡。这是一种最典型最直接的处理方式来避免人员(thread)等待。事实上RxJava就是这么做的。observeOn操作符就带有一个bufferSize参数可以设置货架的大小。",
			"虽然拉模型看上去很美，但是我们做服务业就得把各种意外考虑进去。"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2018-05-06T00:00:00.000Z",
		"updated": "Mon Mar 08 2021 14:04:34 GMT+0800 (China Standard Time)",
		"tags": [
			"RxJava",
			"Java"
		],
		"categories": [
			"Coding"
		],
		"date": "2018-05-06T00:00:00.000Z",
		"prev": "3.md"
	},
	{
		"path": "public/blog/posts/topics/rxjava/3.md",
		"link": "/blog/posts/topics/rxjava/3",
		"title": "理解RxJava与响应式(3) - 线程调度",
		"summary": [
			"RxJava 为我们提供了两个调度操作符subscribeOn和observeOn.",
			"Sample Code"
		],
		"image": "images/Scheduler.png",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2018-05-05T00:00:00.000Z",
		"updated": "Mon Mar 08 2021 14:04:34 GMT+0800 (China Standard Time)",
		"tags": [
			"RxJava",
			"Java"
		],
		"categories": [
			"Coding"
		],
		"date": "2018-05-05T00:00:00.000Z",
		"prev": "2.md",
		"next": "4.md"
	},
	{
		"path": "public/blog/posts/topics/rxjava/2.md",
		"link": "/blog/posts/topics/rxjava/2",
		"title": "理解RxJava与响应式(2) - 操作符",
		"summary": [
			"继续刚才KFC的例子。\n我们都知道吮指原味鸡来自于鸡的不同部位，分别有鸡腿，鸡胸和鸡肋。",
			"现在我这个人很挑，不吃鸡肋，该怎么办呢。",
			"最直接的想法，我们当然可以很直接在KFC(Publisher)内做判断。",
			"但是很快我们就发现了问题",
			"想象一条流水线，KFC是起点，我是终点，我们不应该让KFC再也不生产鸡肋，而是应该在流水线上安排一个工人(KFC服务员)，由服务员来帮我们过滤鸡肋。KFC对服务员负责，服务员对我负责。"
		],
		"image": "images/Reactive-Model.png",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2018-05-04T00:00:00.000Z",
		"updated": "Mon Mar 08 2021 14:04:34 GMT+0800 (China Standard Time)",
		"tags": [
			"RxJava",
			"Java"
		],
		"categories": [
			"Coding"
		],
		"date": "2018-05-04T00:00:00.000Z",
		"prev": "1.md",
		"next": "3.md"
	},
	{
		"path": "public/blog/posts/topics/rxjava/1.md",
		"link": "/blog/posts/topics/rxjava/1",
		"title": "理解RxJava与响应式(1) - 响应式流",
		"summary": [
			"Reactive-streams 是 RxJava的唯一依赖，它是一项响应式编程API标准，已被java标准库收录。",
			"Reactive-streams只定义了4个接口共计7个方法，这7个方法构成了整个Reactive世界。",
			"由于这些方法都太直观了没什么好说的，我就举个例子",
			"Sample Code"
		],
		"image": "",
		"author": "Dean Xu",
		"contributors": [
			"Dean Xu",
			"dxu"
		],
		"created": "2018-05-03T00:00:00.000Z",
		"updated": "Mon Mar 08 2021 14:04:34 GMT+0800 (China Standard Time)",
		"tags": [
			"RxJava",
			"Java"
		],
		"categories": [
			"Coding"
		],
		"date": "2018-05-03T00:00:00.000Z",
		"next": "2.md"
	}
]