[
  {
    "path": "public/blog/posts/topics/spring-boot/jpa/envers/1.md",
    "link": "/blog/posts/topics/spring-boot/jpa/envers/1",
    "title": "Spring Boot JPA - Hibernate Envers",
    "summary": [
      "虽然Spring Data JPA有默认的Auditing功能，但是功能还是相对单薄。",
      "而Hibernate Envers是Hibernate提供的完整Auditing方案，可以记录Entity的历史版本和版本信息。\n可以帮助找回丢失数据，检查修改历史以及数据分析。",
      "Hibernate Envers和Spring Data JPA无缝集成，只需要简单地加上注解就可以工作。",
      "首先需要添加依赖项",
      "接着，在你的Entity类上打上@Audited，就大功告成了。\n现在一个最简单的审计功能已经可以正常工作"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2020-08-04T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Java",
      "Spring Boot",
      "Hibernate"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2020-08-04T00:00:00.000Z",
    "src": [
      {
        "text": "Source Code",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/jpa/audit"
      }
    ]
  },
  {
    "path": "public/blog/posts/topics/spring-boot/extra/5-async.md",
    "link": "/blog/posts/topics/spring-boot/extra/5-async",
    "title": "Spring Boot 番外 (05) - 异步 Async",
    "summary": [
      "在Java中，异步操作通常需要自己开启线程或者管理线程池。",
      "到了Spring Boot中，通过容器的特性在上下文中提供线程池，可以做到轻松方便的异步操作。\nSpring Boot提供了@Async异步注解，让我们可以彻底告别过去，不需要处处和线程/线程池打交道。",
      "要开启异步功能，只需要添加上@EnableAsync注解即可。",
      "开启后，在你想要异步操作的方法加上@Async注解就大功告成了。",
      "@Async方法返回值必须为以下几种类型之一"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2020-04-28T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Java",
      "Spring Boot"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2020-04-28T00:00:00.000Z",
    "prev": "4-caching.md",
    "src": [
      {
        "text": "Async",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/async"
      }
    ]
  },
  {
    "path": "public/blog/posts/topics/spring-boot/extra/4-caching.md",
    "link": "/blog/posts/topics/spring-boot/extra/4-caching",
    "title": "Spring Boot 番外 (04) - 缓存 Cache",
    "summary": [
      "对于程序员，缓存一定不是一个陌生的概念。\n在我们编写的程序中，数据的处理和传递无时无刻不在发生着。\n而其中总会存在着一些的重复的操作和数据。",
      "为了减少这种浪费，也为了加快响应时间，我们就需要缓存。\n把处理好的数据保留下来(最常见的是放在内存)，下次再要做相同的事情，就可以直接返回结果。",
      "Spring Boot核心库就为我们提供了缓存功能，相关代码在org.springframework.cache包下。",
      "要开启缓存功能，只需要添加上@EnableCaching注解即可。\n接着我们就要在需要的方法上加上注解来实现缓存。\nSpring Boot提供了以下几种注解。",
      "其中，前三个注解是核心，每个注解都有若干配置，所以配置的含义都会在后面一一讲解。"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2020-02-10T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Java",
      "Spring Boot"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2020-02-10T00:00:00.000Z",
    "prev": "3-encrypt.md",
    "next": "5-async.md",
    "src": [
      {
        "text": "Caching",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/cache"
      }
    ]
  },
  {
    "path": "public/blog/posts/topics/spring-boot/extra/3-encrypt.md",
    "link": "/blog/posts/topics/spring-boot/extra/3-encrypt",
    "title": "Spring Boot 番外 (03) - 敏感信息加密 Encrypt",
    "summary": [
      "在所有的应用中，我们会需要一些配置信息，其中难免会有一些敏感信息。\n如果明文将他们放到仓库里，这些信息就会泄露。而如果我们不放在仓库里，又会给我们的部署带来麻烦。\n因此，加密敏感信息就成了必要的需求了。",
      "基于Spring Boot的容器特性，我们其实很容易切入配置文件的加载，来处理加密信息。",
      "我们想要的是，把编码后的数据放到配置中，而在容器里拿到的却是解码后的内容。",
      "所以首先我们得有一条绝密的字符串Hello World，然后我们用复杂的BASE64算法进行编码，得到了SGVsbG8gV29ybGQ=。\n把它放到application.yaml里。为了区别于未加密的信息，我们以base64:开头：",
      "现在我们可以开始写我们的解密处理器了"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2020-02-04T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Java",
      "Spring Boot"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2020-02-04T00:00:00.000Z",
    "prev": "2-custom-condition.md",
    "next": "4-caching.md",
    "src": [
      {
        "text": "Custom Encrypt",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/encrypt/src/main/java/xdean/share/spring/encrypt/custom"
      },
      {
        "text": "Jasypt Encrypt",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/encrypt/src/main/java/xdean/share/spring/encrypt/jasypt"
      }
    ]
  },
  {
    "path": "public/blog/posts/topics/spring-boot/6.md",
    "link": "/blog/posts/topics/spring-boot/6",
    "title": "Spring Boot (06) - Auto Configuration 自动配置 与 Starter 启动器",
    "summary": [
      "前面几节讲解了Spring容器以及Bean的用法。\n其实至此Spring的核心功能已经结束了，从本节往后所有的功能不过是在容器之内所做的拓展。\n对于Spring Boot自己来说，最重要的功能就是Auto Configuration(自动配置)了。",
      "对于经历过传统Spring的开发者来说，Spring Boot无疑是大大解放了生产力。\n其\"约定优于配置\"的思想将我们从无数的配置文件中解放出来。\n大部分时候我们不需要任何配置就可以获得想要的对象。",
      "例如在我们第一节的Hello-Web中，没有做任何Web相关配置却成功的启动了一个Web服务。\n又比如如果你想要一个内存数据库，只需要引入HSQLDB作为依赖而不需要任何配置，一个数据库连接就被置入了容器之中。\n这些都是得益于Auto Configuration特性。",
      "要启用自动配置功能，只需要使用@EnableAutoConfiguration注解。\n默认地，@SpringBootApplication注解已经包含了该注解。",
      "每个自动配置其实就是一个Java类，如果想要禁用特定地自动配置，只需要在@EnableAutoConfiguration上排除相应地类。\n如@Enab"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2019-11-04T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Java",
      "Spring Boot"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2019-11-04T00:00:00.000Z",
    "prev": "5.md"
  },
  {
    "path": "public/blog/posts/2019/ui-task-optimize/ui-task-optimize.md",
    "link": "/blog/posts/2019/ui-task-optimize/ui-task-optimize",
    "title": "UI事件线程任务调度优化",
    "summary": [
      "一般UI框架都是单线程事件模型。一个典型的UI线程如图",
      "在UI初始化后，除了不断地处理用户事件以外。还会维护一个事件队列以接收其他线程调度来的任务。UI框架会提供接口以调度任务回UI线程。例如",
      "一般对于耗时操作，我们会先在任务线程里运行，得到结果后调度回到UI线程进行更新。",
      "但是对于一些特定业务，即使调度得到也仍会造成UI卡顿。例如：",
      "针对以上两种情况，我们对UI事件线程进行优化。通过自定义的调度器来取代原生调度器，从而使UI更加顺滑。\n我们先来看看解决问题的效果，然后解析实现原理。"
    ],
    "image": "ui-loop.svg",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2019-10-15T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Java",
      "GUI"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2019-10-15T00:00:00.000Z",
    "src": [
      {
        "text": "FxRunCenter",
        "url": "https://github.com/XDean/Share/blob/master/src/main/java/xdean/share/gui/schedule/FxRunCenter.java"
      }
    ]
  },
  {
    "path": "public/blog/posts/topics/spring-boot/extra/2-custom-condition.md",
    "link": "/blog/posts/topics/spring-boot/extra/2-custom-condition",
    "title": "Spring Boot 番外 (02) - 自定义Condition",
    "summary": [
      "Spring Boot提供了Condition接口来自定义Conditional。它只有一个方法",
      "同时，对于每个Condition要定义对应的注解以标记Bean需要满足该条件。",
      "这里我们依然以'世界'为例，在不同的世界里我们需要不同的Bean。",
      "首先我们实现WorldCondition",
      "接着我们再定义对应的注解@OnWorld，指定WorldCondition为它的处理类"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2019-09-10T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Java",
      "Spring Boot"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2019-09-10T00:00:00.000Z",
    "prev": "1-custom-scope.md",
    "next": "3-encrypt.md",
    "src": [
      {
        "text": "WorldScope",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/customcondition"
      }
    ]
  },
  {
    "path": "public/blog/posts/topics/spring-boot/extra/1-custom-scope.md",
    "link": "/blog/posts/topics/spring-boot/extra/1-custom-scope",
    "title": "Spring Boot 番外 (01) - 自定义Scope",
    "summary": [
      "ConfigurableBeanFactory提供了接口來进行自定义Scope的注册",
      "我们只需要实现Scope接口，注意这里的Scope不是注解@Scope。",
      "Scope接口有如下定义(下文中所有上下文均指代作用域的上下文)",
      "Spring附赠了一个简单实现的SimpleThreadScope可以作为参考。",
      "在这里我们一起来创建一个新的WorldScope(平行世界)，通过一个全局的世界标识符来决定当前上下文。"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2019-09-09T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Java",
      "Spring Boot"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2019-09-09T00:00:00.000Z",
    "next": "2-custom-condition.md",
    "src": [
      {
        "text": "WorldScope",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/customscope"
      }
    ]
  },
  {
    "path": "public/blog/posts/topics/spring-boot/5.md",
    "link": "/blog/posts/topics/spring-boot/5",
    "title": "Spring Boot (05) - Bean的配置与生命周期",
    "summary": [
      "Spring Boot提供了一系列的注解来帮助我们配置Bean，从而正确地找到合适地依赖项。",
      "在Spring中，Bean默认是单例的，如果想要非单例的Bean，你需要定义@Scope，即作用域。",
      "在Spring核心库中，只有两种scope，singleton和prototype。\n同时你也可以根据业务需求自定义scope，如Spring-Web中有request,session等",
      "例如",
      "输出"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2019-09-05T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Java",
      "Spring Boot"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2019-09-05T00:00:00.000Z",
    "prev": "4.md",
    "next": "6.md",
    "src": [
      {
        "text": "@Scope",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/scope"
      },
      {
        "text": "@Conditional",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/conditional"
      },
      {
        "text": "@DependsOn",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/dependson"
      },
      {
        "text": "生命周期",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/lifecycle"
      }
    ]
  },
  {
    "path": "public/blog/posts/topics/spring-boot/4.md",
    "link": "/blog/posts/topics/spring-boot/4",
    "title": "Spring Boot (04) - Bean的发现",
    "summary": [
      "上文讲到如何将Bean注册到容器中。整个过程看上去像是魔法一样，没有任何耦合，只是加了一个注解就完成了。",
      "其实秘密就藏在了注解里，注解包含了配置项，Spring容器解析注解从而找到你的Bean。",
      "在Spring中主要有两种方式发现你的Bean",
      "@ComponentScan告诉Spring容器通过类路径扫描来发现用户定义的Bean。\n你可能会想你并没有定义过这一注解，让我们点开@SpringBootApplication类源码，你会发现它已经包含了@ComoponentScan。",
      "@ComponentScan`主要属性有"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2019-09-03T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Java",
      "Spring Boot"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2019-09-03T00:00:00.000Z",
    "prev": "3.md",
    "next": "5.md",
    "src": [
      {
        "text": "@ComponentScan",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/componentscan"
      },
      {
        "text": "@Import",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/importoutside"
      },
      {
        "text": "Spring Boot 源码",
        "url": "https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java"
      }
    ]
  },
  {
    "path": "public/blog/posts/2019/go-enc-config.md",
    "link": "/blog/posts/2019/go-enc-config",
    "title": "Go - 配置文件加密",
    "summary": [
      "任何应用都不可避免地要使用配置文件，而一些配置信息包含敏感信息，如果明文放在配置文件中上传到远程仓库里显然是不合适地。",
      "一种做法是在仓库里不记录敏感信息，而在生产环境下单独配置。这样虽然保护了信息但是会变得非常麻烦，换一个环境又要重新配置。",
      "而我的做法是直接在配置文件中加密，通过一个统一密钥来管理所有的敏感信息。",
      "我们有如下配置项",
      "对应的我们有"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2019-09-02T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Golang"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2019-09-02T00:00:00.000Z",
    "src": [
      {
        "text": "源码",
        "url": "https://github.com/XDean/goex/blob/master/xconfig/encrypt.go"
      },
      {
        "text": "示例",
        "url": "https://github.com/XDean/Share/tree/master/src/go/config/enc"
      }
    ]
  },
  {
    "path": "public/blog/posts/topics/spring-boot/3.md",
    "link": "/blog/posts/topics/spring-boot/3",
    "title": "Spring Boot (03) - 容器与Bean",
    "summary": [
      "在开篇\"Spring Boot是什么\"一节，我们讲到Spring Boot是一个容器。\n如果你有心翻看Spring Boot Starter的依赖，你会发现除了包含基础设施的spring-core项目外，最主要的项目便是spring-context，直译为上下文，亦即容器。",
      "即使你没有用过Spring也一定听过依赖注入/控制反转。\n在大型项目中，代码中存在千丝万缕的依赖关系，如果不能正确管理这些依赖关系，生产效率和质量都会大打折扣。例如下面这个例子",
      "A依赖于B，这看上去没什么问题，但是想象一下让你来写这段代码，问题迎面而来",
      "紧接着再来想象一下让你来维护这段代码",
      "无数问题将困扰开发人员，使得我们花了太多的功夫在依赖上，而占用了我们开发A业务逻辑的精力。"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2019-08-30T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Java",
      "Spring Boot"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2019-08-30T00:00:00.000Z",
    "prev": "2.md",
    "next": "4.md",
    "src": [
      {
        "text": "@Component",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/component"
      },
      {
        "text": "@Bean",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/bean"
      },
      {
        "text": "@Autowired",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/inject/src/main/java/xdean/share/spring/inject/autowired"
      }
    ]
  },
  {
    "path": "public/blog/posts/topics/spring-boot/2.md",
    "link": "/blog/posts/topics/spring-boot/2",
    "title": "Spring Boot (02) - 元注解",
    "summary": [
      "在Spring Boot中大量使用注解来简化配置。\n但是随着注解的增加，重复的注解本身又变得繁琐。",
      "所以Spring Boot定义了新的元注解(Meta-Annotation)结构来简化重复注解的配置。",
      "注意：Spring Boot元注解的定义方式只作用于由Spring Boot框架解析的注解。其他第三方项目的注解不一定使用了这一框架来解析。",
      "现在我们有一组常用的配置，我们需要在很多地方重复定义",
      "而在Spring Boot中你可以这样定义"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2019-08-28T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Java",
      "Spring Boot"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2019-08-28T00:00:00.000Z",
    "src": [
      {
        "text": "AnnotationUtils",
        "url": "https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java"
      },
      {
        "text": "SynthesizedAnnotationInvocationHandler",
        "url": "https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-core/src/main/java/org/springframework/core/annotation/SynthesizedAnnotationInvocationHandler.java"
      },
      {
        "text": "AbstractAliasAwareAnnotationAttributeExtractor",
        "url": "https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-core/src/main/java/org/springframework/core/annotation/AbstractAliasAwareAnnotationAttributeExtractor.java"
      }
    ],
    "prev": "1.md",
    "next": "3.md"
  },
  {
    "path": "public/blog/posts/topics/spring-boot/1.md",
    "link": "/blog/posts/topics/spring-boot/1",
    "title": "Spring Boot (01) - Hello World",
    "summary": [
      "尽管网上已经有许许多多的Spring Boot教程，但是其侧重点总是在如何搭建和配置WEB服务而非Spring Boot本身。\n本教程将着重于Spring Boot本身，一方面介绍核心特性的用法，一方面结合源码一步步揭开Spring Boot的\"魔法\"。",
      "Spring Boot提供的是一个快速开发框架，在其之上集成了许多组件集合可以开发各类应用，其中最常见的就是Web服务。本教程将主要针对Spring Boot本身和Spring Boot Web进行讲解。",
      "首先我们创建一个标准的maven工程，然后添加以下内容",
      "在dependencyManagement引入spring-boot-starter-parent来管理依赖，这样所有Spring Boot相关依赖不再需要声明版本。",
      "有关maven import scope的详细内容请参看官方文档"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2019-08-26T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Java",
      "Spring Boot"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2019-08-26T00:00:00.000Z",
    "src": [
      {
        "text": "Hello World",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/hello-world"
      },
      {
        "text": "Hello Web",
        "url": "https://github.com/XDean/Share/tree/master/src/spring-boot/hello-web"
      }
    ],
    "next": "2.md"
  },
  {
    "path": "public/blog/posts/2019/database-normalize.md",
    "link": "/blog/posts/2019/database-normalize",
    "title": "Database Normalize 数据库正则化",
    "summary": [
      "Database normalization is the process of structuring a relational database in accordance with a series of so-called normal forms in order to reduce data redundancy and improve data integrity. It was first proposed by Edgar F. Codd as an integral part of his relational model.\nNormalization entails organizing the columns (attributes) and tables (relations) of a database to ensure that their dependencies are properly enforced by database integrity constraints. It is accomplished by applying some formal rules e"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2019-06-27T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Database"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2019-06-27T00:00:00.000Z"
  },
  {
    "path": "public/blog/posts/2018/java-memory-model.md",
    "link": "/blog/posts/2018/java-memory-model",
    "title": "理解Java内存模型",
    "summary": [
      "几天前我在stackoverflow上遇到了一个有趣的问题，我们从这个问题开谈起",
      "@Nik Kotovski:",
      "听说volatile可以阻止重排序，那么他的作用范围是多大呢？一行，一个大括号还是多少？举例：",
      "可以肯定的是k和v肯定不会重排序，那么i,j,flag和v呢？i,j,k之间呢？",
      "我的回答很长，浓缩成一句即是"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2018-10-12T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Java",
      "Memory Model"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2018-10-12T00:00:00.000Z"
  },
  {
    "path": "public/blog/posts/2018/lambda/3-samples-and-hints.md",
    "link": "/blog/posts/2018/lambda/3-samples-and-hints",
    "title": "Lambda表达式(3) - 建议用法与示例",
    "summary": [],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2018-07-12T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Lambda",
      "Java"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2018-07-12T00:00:00.000Z",
    "prev": "2-lambda-vs-method-reference.md"
  },
  {
    "path": "public/blog/posts/2018/lambda/2-lambda-vs-method-reference.md",
    "link": "/blog/posts/2018/lambda/2-lambda-vs-method-reference",
    "title": "Lambda表达式(2) - VS 方法引用",
    "summary": [],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2018-07-11T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Lambda",
      "Java"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2018-07-11T00:00:00.000Z",
    "prev": "1-lambda-vs-anonymous.md",
    "next": "3-samples-and-hints.md"
  },
  {
    "path": "public/blog/posts/2018/lambda/1-lambda-vs-anonymous.md",
    "link": "/blog/posts/2018/lambda/1-lambda-vs-anonymous",
    "title": "Lambda表达式(1) - VS 匿名内部类",
    "summary": [],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2018-07-10T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "Lambda",
      "Java"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2018-07-10T00:00:00.000Z",
    "next": "2-lambda-vs-method-reference.md"
  },
  {
    "path": "public/blog/posts/2018/rxjava/4-BackPressure.md",
    "link": "/blog/posts/2018/rxjava/4-BackPressure",
    "title": "理解RxJava与响应式(4) - 背压",
    "summary": [
      "我们还是以吮指原味鸡为例，KFC分为后厨和前台。后厨产鸡(producer)，前台卖鸡(consumer)，由不同的人(thread)来负责。",
      "两种策略各有优劣，",
      "在实践中应该选用合适的模型。",
      "为了防止顾客久等，KFC在前台和后厨之间放置了一个货架(buffer)，用来暂时存放多于的鸡。这是一种最典型最直接的处理方式来避免人员(thread)等待。事实上RxJava就是这么做的。observeOn操作符就带有一个bufferSize参数可以设置货架的大小。",
      "虽然拉模型看上去很美，但是我们做服务业就得把各种意外考虑进去。"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2018-05-06T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "RxJava",
      "Java"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2018-05-06T00:00:00.000Z",
    "prev": "3-Scheduler.md"
  },
  {
    "path": "public/blog/posts/2018/rxjava/3-Scheduler.md",
    "link": "/blog/posts/2018/rxjava/3-Scheduler",
    "title": "理解RxJava与响应式(3) - 线程调度",
    "summary": [
      "RxJava 为我们提供了两个调度操作符subscribeOn和observeOn.",
      "Sample Code"
    ],
    "image": "images/Scheduler.png",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2018-05-05T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "RxJava",
      "Java"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2018-05-05T00:00:00.000Z",
    "prev": "2-Operator.md",
    "next": "4-BackPressure.md"
  },
  {
    "path": "public/blog/posts/2018/rxjava/2-Operator.md",
    "link": "/blog/posts/2018/rxjava/2-Operator",
    "title": "理解RxJava与响应式(2) - 操作符",
    "summary": [
      "继续刚才KFC的例子。\n我们都知道吮指原味鸡来自于鸡的不同部位，分别有鸡腿，鸡胸和鸡肋。",
      "现在我这个人很挑，不吃鸡肋，该怎么办呢。",
      "最直接的想法，我们当然可以很直接在KFC(Publisher)内做判断。",
      "但是很快我们就发现了问题",
      "想象一条流水线，KFC是起点，我是终点，我们不应该让KFC再也不生产鸡肋，而是应该在流水线上安排一个工人(KFC服务员)，由服务员来帮我们过滤鸡肋。KFC对服务员负责，服务员对我负责。"
    ],
    "image": "images/Reactive-Model.png",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2018-05-04T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "RxJava",
      "Java"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2018-05-04T00:00:00.000Z",
    "prev": "1-Reactive-API.md",
    "next": "2-Operator.md"
  },
  {
    "path": "public/blog/posts/2018/rxjava/1-Reactive-API.md",
    "link": "/blog/posts/2018/rxjava/1-Reactive-API",
    "title": "理解RxJava与响应式(1) - 响应式流",
    "summary": [
      "Reactive-streams 是 RxJava的唯一依赖，它是一项响应式编程API标准，已被java标准库收录。",
      "Reactive-streams只定义了4个接口共计7个方法，这7个方法构成了整个Reactive世界。",
      "由于这些方法都太直观了没什么好说的，我就举个例子",
      "Sample Code"
    ],
    "image": "",
    "author": "Dean Xu",
    "contributors": [
      "Dean Xu",
      "dxu"
    ],
    "created": "2018-05-03T00:00:00.000Z",
    "updated": "Sat Mar 06 2021 08:59:40 GMT+0800 (China Standard Time)",
    "tags": [
      "RxJava",
      "Java"
    ],
    "categories": [
      "Coding"
    ],
    "date": "2018-05-03T00:00:00.000Z",
    "next": "2-Operator.md"
  }
]